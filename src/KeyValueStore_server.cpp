// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "KeyValueStore.h"
#include <transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <map>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace std;

using namespace  ::KeyValueStore;

enum op_type
{
    type_add = 0,
    type_remove,
    type_put
};

class KeyValueStoreHandler : virtual public KeyValueStoreIf {
 public:
  KeyValueStoreHandler(int argc, char** argv) {
    // Your initialization goes here
    _id = atoi(argv[1]);
    int index = 0;

    for(int i = 3; i+1 < argc; i += 2) {
      if (index == _id) {
        _backendServerVector.push_back(make_pair("localhost", atoi(argv[2])));
      }
      string peer_ip(argv[i]);
      int peer_port = atoi(argv[i+1]);
      _backendServerVector.push_back(make_pair(peer_ip, peer_port));
      cout << "Backend server at: " << peer_ip << " on port: " << peer_port << endl;
    }

    _cur_index = 0;
  }

  void Get(GetResponse& _return, const std::string& key) {
    // Your implementation goes here
    string::size_type pos;
    cout << "Get " << key << endl;

    pos = key.find("_user");
    if (pos != key.npos) {
	if (user_list.find(key) == user_list.end()) {
	    _return.status = KVStoreStatus::EKEYNOTFOUND;
	    return;
	}

	_return.value = user_list[key];
	_return.status =  KVStoreStatus::OK;
	return;
    }

    if (time_tribble_list.find(key) == time_tribble_list.end()) {
	_return.status = KVStoreStatus::EKEYNOTFOUND;
	return;
    }

    _return.value = time_tribble_list[key];
    _return.status =  KVStoreStatus::OK;
    return;
  }

  struct decrease
  {
	inline bool operator() (const string& i1, const string& i2)
	{
		return atoi(i1.c_str()) > atoi(i2.c_str());
	}
  };

  void GetList(GetListResponse& _return, const std::string& key) {
    // Your implementation goes here
    cout << "GetList " << key << endl;
    string::size_type pos;
    std::vector<string> timelist;

    pos = key.find("_sublist");
    if (pos != key.npos) {
	if (subscription_list.find(key) == subscription_list.end()) {
	    _return.status = KVStoreStatus::EKEYNOTFOUND;
	    return;
	}
	_return.values = subscription_list[key];
	_return.status = KVStoreStatus::OK;
	return;
    }

    pos = key.find("_tribbles");
    if (pos != key.npos) {
	if (user_time_list.find(key) == user_time_list.end()) {
	    _return.status = KVStoreStatus::EKEYNOTFOUND;
	    return;
	}

	timelist = user_time_list[key];
	sort(timelist.begin(), timelist.end(), decrease());
	if (timelist.size() > 100)
	    timelist.resize(100);

	_return.values = timelist;
	_return.status = KVStoreStatus::OK;
	return;
    }

    _return.status =  KVStoreStatus::INTERNAL_FAILURE;
  }

  KVStoreStatus::type Put(const std::string& key, const std::string& value, const std::string& clientid) {
    string::size_type pos;
    // Your implementation goes here

    cout << "Put " << key << " " << value << endl;
    pos = key.find("_user");
    if (pos != key.npos) {
	if (user_list.find(key) != user_list.end()) {
	    return KVStoreStatus::EITEMEXISTS;
	}

	user_list[key] = value;
	goto finish;
    }

    if (time_tribble_list.find(key) != time_tribble_list.end()) {
	return KVStoreStatus::EITEMEXISTS;
    }

    time_tribble_list[key] = value;

finish:
    if (clientid == "t_s")
	PropagateToOtherServers(type_put, key, value, clientid); 
    cout << "Put finished " << key << " " << value << endl;
    return  KVStoreStatus::OK;

  }

  int get_userid_from_tribble(const std::string& tribble_string,
				string& id)
  {
    int userid_start = 2;
    unsigned int userid_end;
    string strset = "}";

    userid_end = tribble_string.find_first_of(strset);
    if (userid_end == string::npos) {
	cout << "Not find }" << endl;
        return -1;
    }
    
    id = tribble_string.substr(userid_start, userid_end - userid_start);
    return 0;

  }

  KVStoreStatus::type AddToList(const std::string& key, const std::string& value, const std::string& clientid) {
    // Your implementation goes here
    cout << "AddToList " << key << " " << value << endl;
    string::size_type pos;
    string index_str;
    string user_id;
    char t[256];
    int ret;

    pos = key.find("_sublist");
    if (pos != key.npos) {
	subscription_list[key].push_back(value);
	return KVStoreStatus::OK;
    }

    if (key == "ts") {
	ret = get_userid_from_tribble(value, user_id);
	if (ret)
	    return KVStoreStatus::INTERNAL_FAILURE;

	sprintf(t, "%d", _cur_index);
	_cur_index++;
	index_str = t;

	if (time_tribble_list.find(index_str)
		!= time_tribble_list.end()) {
	    return KVStoreStatus::EITEMEXISTS;
	}
	index_str = t;
	time_tribble_list[index_str] = value;
	user_id += "_tribbles";
	user_time_list[user_id].push_back(index_str);

	return KVStoreStatus::OK;
    }

    return KVStoreStatus::INTERNAL_FAILURE;
  }

  KVStoreStatus::type RemoveFromList(const std::string& key, const std::string& value, const std::string& clientid) {
    // Your implementation goes here
    cout << "RemoveFromList " << key << " " << value << endl;
    string::size_type pos;
    std::vector<string> *sub_list;
    std::vector<string>::iterator iter;

    pos = key.find("_sublist");
    if (pos != key.npos) {
	if (subscription_list.find(key) == subscription_list.end()) {
	    return KVStoreStatus::EKEYNOTFOUND;
	}

	sub_list = &subscription_list[key];
	iter = find(sub_list->begin(), sub_list->end(), value);
	if (iter == sub_list->end()) {
	    return KVStoreStatus::EKEYNOTFOUND;
	} else {
	    sub_list->erase(iter);
	    return KVStoreStatus::OK;
	}
    }

    return KVStoreStatus::NOT_IMPLEMENTED;
  }

  KVStoreStatus::type PropagateToOtherServers(enum op_type type, std::string key, std::string value, std::string clientid) {
    // Making the RPC Call to the Storage server
    std::vector<pair<string, int> >::iterator iter;
    std::string storageServer;
    int storageServerPort;
    KVStoreStatus::type st;

    for (iter = _backendServerVector.begin(); iter != _backendServerVector.end(); ++iter) {
	storageServer = iter->first;
	storageServerPort = iter->second;
	cout << "Propagate to server " << storageServer << " " << storageServerPort << endl;
	boost::shared_ptr<TSocket> socket(new TSocket(storageServer, storageServerPort));
	boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
	boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
	KeyValueStoreClient client(protocol);
	socket->setConnTimeout(100);
	socket->setRecvTimeout(100);
	socket->setSendTimeout(100);
	try {
	    transport->open();
	    switch (type) {
	    case type_add:
		st = client.AddToList(key, value, clientid);
		break;
	    case type_remove:
		st = client.RemoveFromList(key, value, clientid);
		break;
	    case type_put:
		st = client.Put(key, value, "b_s");
		break;
	    default:
		st = KVStoreStatus::INTERNAL_FAILURE;
		break;
	    }
	    transport->close();
	} catch (TException &tx) {
	    cout << "ERROR: %s" << tx.what() << endl;
	    continue;
	}
    }
    return st;
  }

    int _id;
    vector < pair<string, int> > _backendServerVector;
    std::map<string, string> user_list;
    std::map<string, vector<string> > subscription_list;
    std::map<string, vector<string> > user_time_list;
    std::map<string, string> time_tribble_list;
    int _cur_index;

};

int main(int argc, char **argv) {
  if((argc < 3) || !(argc % 2)) {
      cerr << "Usage: " << argv[0] << " id localport peer1 port1..." << endl;
      exit(1);
  }
  int port = atoi(argv[2]);
  shared_ptr<KeyValueStoreHandler> handler(new KeyValueStoreHandler(argc, argv));
  shared_ptr<TProcessor> processor(new KeyValueStoreProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

